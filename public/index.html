<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>SaskTel Canvas Login</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
      background: #000;
    }

    canvas {
      display: block;
      touch-action: manipulation;
    }

    #hiddenInput {
      position: absolute;
      background: transparent;
      border: none;
      color: transparent;
      caret-color: black;
      font-size: 28px;
      z-index: 10;
      opacity: 0;
    }
  </style>
</head>
<body>

<canvas id="loginCanvas"></canvas>
<input type="text" id="hiddenInput" autocomplete="off" autocapitalize="none" />

<script>
const canvas = document.getElementById('loginCanvas');
const ctx = canvas.getContext('2d');
const hiddenInput = document.getElementById('hiddenInput');

// Fullscreen canvas
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  draw();
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let loginID = '';
let password = '';
let activeInput = null;
let loginTouched = false;
let passTouched = false;

const loginBox  = { x: 29, y: 368, width: 662, height: 100 };
const passBox   = { x: 29, y: 586, width: 662, height: 100 };
const buttonBox = { x: 29, y: 795, width: 662, height: 64 };
const designWidth = 720;
const designHeight = 1402;

let bgLoaded = false;
const bgImage = new Image();
bgImage.src = 'background.png';
bgImage.onload = () => {
  console.log('✅ background.png loaded');
  bgLoaded = true;
  draw();
};
bgImage.onerror = () => {
  console.warn('⚠️ background.png failed to load — fallback color used.');
  draw();
};

// Blink cursor
let cursorVisible = true;
setInterval(() => {
  cursorVisible = !cursorVisible;
  if (activeInput) draw();
}, 500);

function scaleRect(rect) {
  const scaleX = canvas.width / designWidth;
  const scaleY = canvas.height / designHeight;
  return {
    x: rect.x * scaleX,
    y: rect.y * scaleY,
    width: rect.width * scaleX,
    height: rect.height * scaleY
  };
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Background
  if (bgLoaded) {
    ctx.drawImage(bgImage, 0, 0, canvas.width, canvas.height);
  } else {
    ctx.fillStyle = '#f0f0f0'; // fallback background color
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }

  drawInputBox(scaleRect(loginBox), loginID, activeInput === 'login');
  drawInputBox(scaleRect(passBox), password.replace(/./g, '•'), activeInput === 'pass');
  drawButton(scaleRect(buttonBox), 'LOG IN');
}

function drawInputBox(box, text, isFocused) {
  const touched = (box === scaleRect(loginBox)) ? loginTouched : passTouched;

  ctx.fillStyle = touched ? '#ffffff' : 'rgba(255,255,255,0.6)';
  ctx.fillRect(box.x, box.y, box.width, box.height);

  ctx.strokeStyle = isFocused ? '#007bff' : '#999';
  ctx.lineWidth = 2;
  ctx.strokeRect(box.x, box.y, box.width, box.height);

  ctx.font = `${box.height * 0.4}px sans-serif`;
  ctx.fillStyle = '#000';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, box.x + 14, box.y + box.height / 2);

  if (isFocused && cursorVisible) {
    const textWidth = ctx.measureText(text).width;
    ctx.beginPath();
    ctx.moveTo(box.x + 14 + textWidth + 2, box.y + 10);
    ctx.lineTo(box.x + 14 + textWidth + 2, box.y + box.height - 10);
    ctx.stroke();
  }
}

function drawButton(box, text) {
  ctx.fillStyle = '#e10098';
  ctx.fillRect(box.x, box.y, box.width, box.height);

  ctx.fillStyle = '#fff';
  ctx.font = `bold ${box.height * 0.5}px sans-serif`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, box.x + box.width / 2, box.y + box.height / 2);
}

function isInside(x, y, box) {
  return x >= box.x && x <= box.x + box.width &&
         y >= box.y && y <= box.y + box.height;
}

function positionHiddenInputOver(box) {
  const rect = canvas.getBoundingClientRect();
  hiddenInput.style.left = rect.left + box.x + 'px';
  hiddenInput.style.top = rect.top + box.y + 'px';
  hiddenInput.style.width = box.width + 'px';
  hiddenInput.style.height = box.height + 'px';
  hiddenInput.style.opacity = 1;
}

function handleTouch(e) {
  const rect = canvas.getBoundingClientRect();
  const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left;
  const y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top;

  const login = scaleRect(loginBox);
  const pass = scaleRect(passBox);
  const button = scaleRect(buttonBox);

  if (isInside(x, y, login)) {
    activeInput = 'login';
    loginTouched = true;
    hiddenInput.value = loginID;
    positionHiddenInputOver(login);
    hiddenInput.focus();
  } else if (isInside(x, y, pass)) {
    activeInput = 'pass';
    passTouched = true;
    hiddenInput.value = password;
    positionHiddenInputOver(pass);
    hiddenInput.focus();
  } else if (isInside(x, y, button)) {
    hiddenInput.blur();
    hiddenInput.style.opacity = 0;

    alert('Would submit: ' + loginID + ' / ' + password);
  } else {
    activeInput = null;
    hiddenInput.blur();
    hiddenInput.style.opacity = 0;
  }

  draw();
}

canvas.addEventListener('touchstart', handleTouch, false);
canvas.addEventListener('mousedown', handleTouch, false);

hiddenInput.addEventListener('input', () => {
  if (activeInput === 'login') {
    loginID = hiddenInput.value;
  } else if (activeInput === 'pass') {
    password = hiddenInput.value;
  }
  draw();
});
</script>

</body>
</html>
